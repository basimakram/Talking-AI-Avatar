<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Conversation App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: url('static/images/background2.jpg') center/cover no-repeat;
            background-attachment: fixed;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            z-index: 1;
        }

        .video-call-container {
            position: relative;
            z-index: 2;
            width: 95%;
            max-width: 1200px;
            height: 90vh;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 20px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        /* Header with timer */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 30px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .avatar-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .avatar-badge {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
        }

        .avatar-details h2 {
            font-size: 20px;
            margin-bottom: 5px;
            color: #fff;
        }

        .avatar-details p {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            max-width: 300px;
        }

        .call-timer {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px;
            font-weight: 600;
            color: #4CAF50;
        }

        .timer-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4CAF50;
            animation: pulse 2s infinite;
        }

        .timer-text {
            font-family: 'Courier New', monospace;
            letter-spacing: 1px;
        }

        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
            100% { opacity: 1; transform: scale(1); }
        }

        /* Main video area */
        .video-area {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.2);
        }

        .avatar-container {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #avatar {
            width: 100%;
            height: 100%;
            border-radius: 0;
        }

        /* Status overlay */
        .status-overlay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 500;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        .status-overlay.listening {
            background: rgba(76, 175, 80, 0.2);
            border-color: #4CAF50;
            color: #4CAF50;
        }

        .status-overlay.processing {
            background: rgba(255, 152, 0, 0.2);
            border-color: #FF9800;
            color: #FF9800;
        }

        .status-overlay.playing {
            background: rgba(33, 150, 243, 0.2);
            border-color: #2196F3;
            color: #2196F3;
        }

        /* Volume indicator */
        .volume-indicator {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
        }

        .volume-bar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722);
            width: 0%;
            transition: width 0.1s ease;
            border-radius: 3px;
        }

        /* Controls footer */
        .controls-footer {
            padding: 25px 30px;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .call-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .start-call {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
        }

        .start-call:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 25px rgba(76, 175, 80, 0.4);
        }

        .end-call {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            color: white;
        }

        .end-call:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 25px rgba(244, 67, 54, 0.4);
        }

        .call-button:active {
            transform: scale(0.95);
        }

        .call-button.recording {
            animation: callPulse 1.5s infinite;
        }

        @keyframes callPulse {
            0% { 
                transform: scale(1);
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 6px 30px rgba(76, 175, 80, 0.6);
            }
            100% { 
                transform: scale(1);
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            }
        }

        .hidden {
            display: none !important;
        }

        /* Audio element */
        audio {
            display: none;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .video-call-container {
                width: 100%;
                height: 100vh;
                border-radius: 0;
            }

            .header {
                padding: 15px 20px;
            }

            .avatar-details h2 {
                font-size: 18px;
            }

            .call-timer {
                font-size: 16px;
            }

            .volume-indicator {
                width: 150px;
            }

            .controls-footer {
                padding: 20px;
            }
        }

        /* Initial state before conversation starts */
        .pre-call-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 15;
            backdrop-filter: blur(5px);
        }

        .pre-call-text {
            text-align: center;
            margin-bottom: 30px;
        }

        .pre-call-text h3 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #fff;
        }

        .pre-call-text p {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.5;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .loading-screen.active {
            opacity: 1;
            visibility: visible;
        }

        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 6px solid rgba(255, 255, 255, 0.2);
            border-top: 6px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 30px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="video-call-container">
        <!-- Header with avatar info and timer -->
        <div class="header">
            <div class="avatar-info">
                <div class="avatar-badge" id="avatarBadge">
                    AS
                </div>
                <div class="avatar-details">
                    <h2 id="avatarName">Adam Sterling</h2>
                    <p id="avatarDesc">Confident, concise, and solution-oriented. Speaks directly, with no patience for fluff.</p>
                </div>
            </div>
            
            <div class="call-timer hidden" id="callTimer">
                <div class="timer-dot"></div>
                <span class="timer-text" id="timerText">00:00</span>
            </div>
        </div>

        <!-- Main video area -->
        <div class="video-area">
            <div class="avatar-container">
                <div id="avatar"></div>
                
                <!-- Status overlay -->
                <div class="status-overlay" id="statusOverlay">
                    Ready to start conversation
                </div>
                
                <!-- Volume indicator -->
                <div class="volume-indicator">
                    <div class="volume-bar" id="volumeBar"></div>
                </div>
            </div>

            <!-- Pre-call overlay -->
            <div class="pre-call-overlay" id="preCallOverlay">
                <div class="pre-call-text">
                    <h3>ðŸ’¬ AI Conversation</h3>
                    <p id="preCallText">Click the call button below to start your<br>voice conversation with Adam Sterling</p>
                </div>
            </div>
        </div>

        <!-- Controls footer -->
        <div class="controls-footer">
            <button class="call-button start-call" id="startBtn" onclick="startConversation()">
                ðŸ“ž
            </button>
            
            <button class="call-button end-call hidden" id="endBtn" onclick="endConversation()">
                ðŸ“ž
            </button>
        </div>

        <!-- Hidden audio element -->
        <audio id="responseAudio"></audio>
    </div>
    
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-spinner"></div>
        <div class="loading-text">Ending conversation...</div>
    </div>
    
    <script type="importmap">
        {
            "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js/+esm",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
            "talkinghead": "/static/modules/talkinghead.mjs",
            "lipsync-en": "/static/modules/lipsync-en.mjs"
            }
        }
    </script>  
    <script type="module">
        import { TalkingHead } from "talkinghead";
        import { LipsyncEn } from "lipsync-en";

        // Expose to global window scope
        window.TalkingHead = TalkingHead;
        window.LipsyncEn = LipsyncEn;
    </script>

    <script>
        let head;
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let conversationActive = false;
        let silenceTimer;
        let audioContext;
        let analyser;
        let microphone;
        let dataArray;
        let silenceThreshold = 30;
        let silenceDelay = 2000;
        let volumeCheckInterval;
        let callStartTime;
        let timerInterval;

        const startBtn = document.getElementById('startBtn');
        const endBtn = document.getElementById('endBtn');
        const statusOverlay = document.getElementById('statusOverlay');
        const volumeBar = document.getElementById('volumeBar');
        const responseAudio = document.getElementById('responseAudio');
        const callTimer = document.getElementById('callTimer');
        const timerText = document.getElementById('timerText');
        const preCallOverlay = document.getElementById('preCallOverlay');

        const selectedAvatar = "{{ avatar }}";

        const avatars = [
            {
                file: 'avatar1.glb',
                name: 'Adam Sterling',
                desc: 'Strategist'
            },
            {
                file: 'avatar2.glb',
                name: 'Layla Rogers',
                desc: 'Philosopher'
            },
            {
                file: 'avatar3.glb',
                name: 'Sarah Elwood',
                desc: 'Empath'
            },
            {
                file: 'avatar4.glb',
                name: 'Raj Mehra',
                desc: 'Comedian'
            },
            {
                file: 'avatar5.glb',
                name: 'Ethan Brooks',
                desc: 'Challenger'
            },
            {
                file: 'avatar6.glb',
                name: 'Daniel Hayes',
                desc: 'Intellectual'
            },
            {
                file: 'avatar7.glb',
                name: 'Zara Qureshi',
                desc: 'Critic'
            },
            {
                file: 'avatar8.glb',
                name: 'Jayden Cole',
                desc: 'Provoker'
            },
            {
                file: 'avatar9.glb',
                name: 'Rizwan Khan',
                desc: 'Spiritual Guide'
            }
            ];

        
        function setAvatarByFile(fileName) {
            const avatar = avatars.find(a => a.file === fileName);
            if (!avatar) {
                console.warn(`Avatar file not found: ${fileName}`);
                return;
            }

            // Set name and description in header
            document.getElementById('avatarName').textContent = avatar.name;
            document.getElementById('avatarDesc').textContent = avatar.desc;

            // Set avatar badge (first two letters of name)
            const initials = avatar.name.split(' ').map(word => word[0]).join('');
            document.getElementById('avatarBadge').textContent = initials;

            // Set pre-call text
            document.getElementById('preCallText').innerHTML =
                `Click the call button below to start your<br>voice conversation with ${avatar.name}`;
        }

        function startTimer() {
            callStartTime = Date.now();
            callTimer.classList.remove('hidden');
            
            timerInterval = setInterval(() => {
                const elapsed = Date.now() - callStartTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                timerText.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            callTimer.classList.add('hidden');
        }

        async function startConversation() {
            try {
                conversationActive = true;
                preCallOverlay.classList.add('hidden');
                startBtn.classList.add('hidden');
                endBtn.classList.remove('hidden');
                
                // Start the timer
                startTimer();
                
                updateStatus('Connecting...', 'processing');
                
                // Initialize avatar when call starts
                if (!head) {
                    await initializeAvatar();
                }
                
                updateStatus('Initializing microphone...', 'processing');
                
                // Get user media
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                
                // Set up audio context for volume monitoring
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                
                analyser.fftSize = 256;
                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                
                // Set up media recorder
                mediaRecorder = new MediaRecorder(stream);
                
                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };
                
                mediaRecorder.onstop = async () => {
                    if (audioChunks.length > 0) {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                        audioChunks = [];
                        await sendAudioToServer(audioBlob);
                    }
                };
                
                // Speak the initial greeting first
                await speakInitialGreeting();
                
            } catch (error) {
                console.error('Error accessing microphone:', error);
                updateStatus('Error accessing microphone. Please allow microphone access.', '');
                resetButtons();
            }
        }

        async function speakInitialGreeting() {
            try {
                updateStatus('Speaking...', 'playing');
                const avatar = selectedAvatar || 'avatar1.glb';

                const audioApiUrl = `/get_initial_greeting?avatar=${encodeURIComponent(avatar)}&` + new Date().getTime();

                const response = await fetch(audioApiUrl);
                const json = await response.json();

                if (!json.audio_url || !json.metadata) {
                    throw new Error("Invalid response from server");
                }

                const { audio_url, metadata } = json;
                
                console.log(metadata);

                const visemes = metadata.visemes.map(v => v.viseme);
                const vtimes = metadata.visemes.map(v => v.start * 1000);
                const vdurations = metadata.visemes.map(v => (v.end - v.start) * 1000);
                const words = metadata.words;
                const wtimes = metadata.wtimes.map(t => t * 1000);
                const wdurations = metadata.wdurations.map(d => d * 1000);

                const audioBuffer = await decodeAudio(audio_url);
                
                await head.speakAudio({
                    audio: audioBuffer,
                    words,
                    wtimes,
                    wdurations,
                    visemes,
                    vtimes,
                    vdurations
                });

                startListening();
                
            } catch (error) {
                console.error('Error loading greeting:', error);
                updateStatus('Error loading greeting. Starting listening...', 'processing');
                if (conversationActive) {
                    setTimeout(() => {
                        if (conversationActive && !isRecording) {
                            startListening();
                        }
                    }, 1000);
                }
            }
        }

        function startListening() {
            if (!conversationActive) return;
            
            if (isRecording) {
                console.log('Already recording, skipping...');
                return;
            }
            
            updateStatus('Listening... Please speak', 'listening');
            startBtn.classList.add('recording');
            
            audioChunks = [];
            
            if (mediaRecorder.state === 'inactive') {
                mediaRecorder.start();
                isRecording = true;
                monitorVolume();
            } else {
                console.log('MediaRecorder not in inactive state:', mediaRecorder.state);
                setTimeout(() => {
                    if (conversationActive && !isRecording) {
                        startListening();
                    }
                }, 100);
            }
        }

        function monitorVolume() {
            if (!isRecording || !conversationActive) return;
            
            volumeCheckInterval = setInterval(() => {
                if (!analyser || !dataArray) return;
                
                analyser.getByteFrequencyData(dataArray);
                
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    sum += dataArray[i];
                }
                const average = sum / dataArray.length;
                
                const volumePercent = (average / 255) * 100;
                volumeBar.style.width = volumePercent + '%';
                
                if (average < silenceThreshold) {
                    if (!silenceTimer) {
                        silenceTimer = setTimeout(() => {
                            if (isRecording && conversationActive) {
                                stopRecording();
                            }
                        }, silenceDelay);
                    }
                } else {
                    if (silenceTimer) {
                        clearTimeout(silenceTimer);
                        silenceTimer = null;
                    }
                }
            }, 100);
        }

        function stopRecording() {
            if (!isRecording) return;
            
            isRecording = false;
            startBtn.classList.remove('recording');
            
            if (volumeCheckInterval) {
                clearInterval(volumeCheckInterval);
                volumeCheckInterval = null;
            }
            
            if (silenceTimer) {
                clearTimeout(silenceTimer);
                silenceTimer = null;
            }
            
            volumeBar.style.width = '0%';
            updateStatus('Processing your message...', 'processing');
            
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
        }

        async function sendAudioToServer(audioBlob) {
            try {
                const formData = new FormData();
                formData.append('audio', audioBlob, 'recording.wav');

                const avatarFile = selectedAvatar || 'avatar1.glb';
                formData.append('avatar', avatarFile);
                
                const response = await fetch('/process_audio', {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.audio_ready) {
                        await playResponseAudio();
                    }
                    if (result.redirect_url) {
                        console.log("Redirecting to:", result.redirect_url);
                        window.location.href = result.redirect_url;
                    }
                } else {
                    console.error('Error uploading audio:', response.statusText);
                    updateStatus('Error processing audio. Retrying...', '');
                    setTimeout(() => {
                        if (conversationActive) startListening();
                    }, 2000);
                }
            } catch (error) {
                console.error('Error sending audio:', error);
                updateStatus('Connection error. Retrying...', '');
                setTimeout(() => {
                    if (conversationActive) startListening();
                }, 2000);
            }
        }

        async function decodeAudio(url) {
            const res = await fetch(url);
            const buf = await res.arrayBuffer();
            return head.audioCtx.decodeAudioData(buf);
        }

        async function playResponseAudio() {
            try {
                updateStatus('Responding...', 'playing');
                
                const audioUrl = '/get_response_audio?' + new Date().getTime();
                responseAudio.src = audioUrl;

                // Parallel: Fetch audio buffer and metadata
                const [audioBuffer, data] = await Promise.all([
                    decodeAudio(audioUrl),
                    fetch('/get_response_metadata').then(res => res.json())
                ]);

                if (data.error) throw new Error(data.error);
                
                responseAudio.onended = () => {
                    if (conversationActive) {
                        setTimeout(() => {
                            if (conversationActive && !isRecording) {
                                startListening();
                            }
                        }, 1000);
                    }
                };
                
                responseAudio.onerror = (error) => {
                    console.error('Error playing audio:', error);
                    updateStatus('Error playing response. Continuing...', '');
                    if (conversationActive) {
                        setTimeout(() => {
                            if (conversationActive && !isRecording) {
                                startListening();
                            }
                        }, 1000);
                    }
                };
                
                const visemes = data.visemes.map(v => v.viseme);
                const vtimes = data.visemes.map(v => v.start * 1000);
                const vdurations = data.visemes.map(v => (v.end - v.start) * 1000);
                const words = data.words;
                const wtimes = data.wtimes.map(t => t * 1000);
                const wdurations = data.wdurations.map(d => d * 1000);

                await head.speakAudio({
                    audio: audioBuffer,
                    words,
                    wtimes,
                    wdurations,
                    visemes,
                    vtimes,
                    vdurations
                });

                startListening();
                
            } catch (error) {
                console.error('Error playing response audio:', error);
                updateStatus('Error playing response. Continuing...', '');
                if (conversationActive) {
                    setTimeout(() => {
                        if (conversationActive && !isRecording) {
                            startListening();
                        }
                    }, 1000);
                }
            }
        }

        function endConversation() {
            // Show loading screen
            const loadingScreen = document.getElementById('loadingScreen');
            loadingScreen.classList.add('active');
            conversationActive = false;
            
            // Stop timer
            stopTimer();
            
            if (isRecording) {
                stopRecording();
            }
            
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            if (volumeCheckInterval) {
                clearInterval(volumeCheckInterval);
                volumeCheckInterval = null;
            }
            
            if (silenceTimer) {
                clearTimeout(silenceTimer);
                silenceTimer = null;
            }
            
            if (mediaRecorder && mediaRecorder.stream) {
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }
            
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            
            volumeBar.style.width = '0%';
            updateStatus('Conversation ended', '');
            resetButtons();
            
            fetch('/end_convo', {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                console.log("Conversation cleared:", data.message);
                // Wait 2 seconds then redirect to home
                setTimeout(() => {
                    window.location.href = '/';
                }, 2000);
            })
            .catch(error => {
                console.error("Error clearing conversation:", error);
                // Hide loading screen on error
                loadingScreen.classList.remove('active');
                
                // Show error status
                updateStatus('Error ending conversation. Please try again.', '');
                
                // Reset buttons so user can try again
                resetButtons();
            });
        }

        function resetButtons() {
            startBtn.classList.remove('hidden', 'recording');
            endBtn.classList.add('hidden');
            preCallOverlay.classList.remove('hidden');
        }

        function updateStatus(message, className) {
            statusOverlay.textContent = message;
            statusOverlay.className = 'status-overlay ' + className;
        }

        window.addEventListener('beforeunload', () => {
            if (conversationActive) {
                endConversation();
            }
        });

        async function initializeAvatar() {
            const avatarEl = document.getElementById("avatar");
            head = new TalkingHead(avatarEl, {
                lipsyncModules: ["en"],
                cameraView: "upper"
            });
            // near top of script
            const params = new URLSearchParams(window.location.search);
            // const avatarFile = params.get('avatar') || 'avatar1.glb';  // default fallback
            const avatarFile = selectedAvatar || 'avatar1.glb';  // fallback if needed
            await head.showAvatar({
                url: `/static/avatar/${avatarFile}`,
                body: "M",
                avatarMood: "neutral",
                ttsLang: "en-GB",
                ttsVoice: "en-GB-Standard-A",
                lipsyncLang: "en"
            });
        }

        document.addEventListener("DOMContentLoaded", () => {
            setAvatarByFile(selectedAvatar);
            // Avatar will be initialized when call starts
            console.log("Page loaded, ready to start call");
        });
    </script>
</body>
</html>